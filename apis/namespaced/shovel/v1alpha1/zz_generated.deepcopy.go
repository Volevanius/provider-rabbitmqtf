//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InfoInitParameters) DeepCopyInto(out *InfoInitParameters) {
	*out = *in
	if in.AckMode != nil {
		in, out := &in.AckMode, &out.AckMode
		*out = new(string)
		**out = **in
	}
	if in.AddForwardHeaders != nil {
		in, out := &in.AddForwardHeaders, &out.AddForwardHeaders
		*out = new(bool)
		**out = **in
	}
	if in.DeleteAfter != nil {
		in, out := &in.DeleteAfter, &out.DeleteAfter
		*out = new(string)
		**out = **in
	}
	if in.DestinationAddForwardHeaders != nil {
		in, out := &in.DestinationAddForwardHeaders, &out.DestinationAddForwardHeaders
		*out = new(bool)
		**out = **in
	}
	if in.DestinationAddTimestampHeader != nil {
		in, out := &in.DestinationAddTimestampHeader, &out.DestinationAddTimestampHeader
		*out = new(bool)
		**out = **in
	}
	if in.DestinationAddress != nil {
		in, out := &in.DestinationAddress, &out.DestinationAddress
		*out = new(string)
		**out = **in
	}
	if in.DestinationApplicationProperties != nil {
		in, out := &in.DestinationApplicationProperties, &out.DestinationApplicationProperties
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationExchange != nil {
		in, out := &in.DestinationExchange, &out.DestinationExchange
		*out = new(string)
		**out = **in
	}
	if in.DestinationExchangeKey != nil {
		in, out := &in.DestinationExchangeKey, &out.DestinationExchangeKey
		*out = new(string)
		**out = **in
	}
	if in.DestinationProperties != nil {
		in, out := &in.DestinationProperties, &out.DestinationProperties
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationProtocol != nil {
		in, out := &in.DestinationProtocol, &out.DestinationProtocol
		*out = new(string)
		**out = **in
	}
	if in.DestinationPublishProperties != nil {
		in, out := &in.DestinationPublishProperties, &out.DestinationPublishProperties
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationQueue != nil {
		in, out := &in.DestinationQueue, &out.DestinationQueue
		*out = new(string)
		**out = **in
	}
	if in.DestinationQueueArguments != nil {
		in, out := &in.DestinationQueueArguments, &out.DestinationQueueArguments
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationURI != nil {
		in, out := &in.DestinationURI, &out.DestinationURI
		*out = new(string)
		**out = **in
	}
	if in.PrefetchCount != nil {
		in, out := &in.PrefetchCount, &out.PrefetchCount
		*out = new(float64)
		**out = **in
	}
	if in.ReconnectDelay != nil {
		in, out := &in.ReconnectDelay, &out.ReconnectDelay
		*out = new(float64)
		**out = **in
	}
	if in.SourceAddress != nil {
		in, out := &in.SourceAddress, &out.SourceAddress
		*out = new(string)
		**out = **in
	}
	if in.SourceDeleteAfter != nil {
		in, out := &in.SourceDeleteAfter, &out.SourceDeleteAfter
		*out = new(string)
		**out = **in
	}
	if in.SourceExchange != nil {
		in, out := &in.SourceExchange, &out.SourceExchange
		*out = new(string)
		**out = **in
	}
	if in.SourceExchangeKey != nil {
		in, out := &in.SourceExchangeKey, &out.SourceExchangeKey
		*out = new(string)
		**out = **in
	}
	if in.SourcePrefetchCount != nil {
		in, out := &in.SourcePrefetchCount, &out.SourcePrefetchCount
		*out = new(float64)
		**out = **in
	}
	if in.SourceProtocol != nil {
		in, out := &in.SourceProtocol, &out.SourceProtocol
		*out = new(string)
		**out = **in
	}
	if in.SourceQueue != nil {
		in, out := &in.SourceQueue, &out.SourceQueue
		*out = new(string)
		**out = **in
	}
	if in.SourceURI != nil {
		in, out := &in.SourceURI, &out.SourceURI
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InfoInitParameters.
func (in *InfoInitParameters) DeepCopy() *InfoInitParameters {
	if in == nil {
		return nil
	}
	out := new(InfoInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InfoObservation) DeepCopyInto(out *InfoObservation) {
	*out = *in
	if in.AckMode != nil {
		in, out := &in.AckMode, &out.AckMode
		*out = new(string)
		**out = **in
	}
	if in.AddForwardHeaders != nil {
		in, out := &in.AddForwardHeaders, &out.AddForwardHeaders
		*out = new(bool)
		**out = **in
	}
	if in.DeleteAfter != nil {
		in, out := &in.DeleteAfter, &out.DeleteAfter
		*out = new(string)
		**out = **in
	}
	if in.DestinationAddForwardHeaders != nil {
		in, out := &in.DestinationAddForwardHeaders, &out.DestinationAddForwardHeaders
		*out = new(bool)
		**out = **in
	}
	if in.DestinationAddTimestampHeader != nil {
		in, out := &in.DestinationAddTimestampHeader, &out.DestinationAddTimestampHeader
		*out = new(bool)
		**out = **in
	}
	if in.DestinationAddress != nil {
		in, out := &in.DestinationAddress, &out.DestinationAddress
		*out = new(string)
		**out = **in
	}
	if in.DestinationApplicationProperties != nil {
		in, out := &in.DestinationApplicationProperties, &out.DestinationApplicationProperties
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationExchange != nil {
		in, out := &in.DestinationExchange, &out.DestinationExchange
		*out = new(string)
		**out = **in
	}
	if in.DestinationExchangeKey != nil {
		in, out := &in.DestinationExchangeKey, &out.DestinationExchangeKey
		*out = new(string)
		**out = **in
	}
	if in.DestinationProperties != nil {
		in, out := &in.DestinationProperties, &out.DestinationProperties
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationProtocol != nil {
		in, out := &in.DestinationProtocol, &out.DestinationProtocol
		*out = new(string)
		**out = **in
	}
	if in.DestinationPublishProperties != nil {
		in, out := &in.DestinationPublishProperties, &out.DestinationPublishProperties
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationQueue != nil {
		in, out := &in.DestinationQueue, &out.DestinationQueue
		*out = new(string)
		**out = **in
	}
	if in.DestinationQueueArguments != nil {
		in, out := &in.DestinationQueueArguments, &out.DestinationQueueArguments
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationURI != nil {
		in, out := &in.DestinationURI, &out.DestinationURI
		*out = new(string)
		**out = **in
	}
	if in.PrefetchCount != nil {
		in, out := &in.PrefetchCount, &out.PrefetchCount
		*out = new(float64)
		**out = **in
	}
	if in.ReconnectDelay != nil {
		in, out := &in.ReconnectDelay, &out.ReconnectDelay
		*out = new(float64)
		**out = **in
	}
	if in.SourceAddress != nil {
		in, out := &in.SourceAddress, &out.SourceAddress
		*out = new(string)
		**out = **in
	}
	if in.SourceDeleteAfter != nil {
		in, out := &in.SourceDeleteAfter, &out.SourceDeleteAfter
		*out = new(string)
		**out = **in
	}
	if in.SourceExchange != nil {
		in, out := &in.SourceExchange, &out.SourceExchange
		*out = new(string)
		**out = **in
	}
	if in.SourceExchangeKey != nil {
		in, out := &in.SourceExchangeKey, &out.SourceExchangeKey
		*out = new(string)
		**out = **in
	}
	if in.SourcePrefetchCount != nil {
		in, out := &in.SourcePrefetchCount, &out.SourcePrefetchCount
		*out = new(float64)
		**out = **in
	}
	if in.SourceProtocol != nil {
		in, out := &in.SourceProtocol, &out.SourceProtocol
		*out = new(string)
		**out = **in
	}
	if in.SourceQueue != nil {
		in, out := &in.SourceQueue, &out.SourceQueue
		*out = new(string)
		**out = **in
	}
	if in.SourceURI != nil {
		in, out := &in.SourceURI, &out.SourceURI
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InfoObservation.
func (in *InfoObservation) DeepCopy() *InfoObservation {
	if in == nil {
		return nil
	}
	out := new(InfoObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InfoParameters) DeepCopyInto(out *InfoParameters) {
	*out = *in
	if in.AckMode != nil {
		in, out := &in.AckMode, &out.AckMode
		*out = new(string)
		**out = **in
	}
	if in.AddForwardHeaders != nil {
		in, out := &in.AddForwardHeaders, &out.AddForwardHeaders
		*out = new(bool)
		**out = **in
	}
	if in.DeleteAfter != nil {
		in, out := &in.DeleteAfter, &out.DeleteAfter
		*out = new(string)
		**out = **in
	}
	if in.DestinationAddForwardHeaders != nil {
		in, out := &in.DestinationAddForwardHeaders, &out.DestinationAddForwardHeaders
		*out = new(bool)
		**out = **in
	}
	if in.DestinationAddTimestampHeader != nil {
		in, out := &in.DestinationAddTimestampHeader, &out.DestinationAddTimestampHeader
		*out = new(bool)
		**out = **in
	}
	if in.DestinationAddress != nil {
		in, out := &in.DestinationAddress, &out.DestinationAddress
		*out = new(string)
		**out = **in
	}
	if in.DestinationApplicationProperties != nil {
		in, out := &in.DestinationApplicationProperties, &out.DestinationApplicationProperties
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationExchange != nil {
		in, out := &in.DestinationExchange, &out.DestinationExchange
		*out = new(string)
		**out = **in
	}
	if in.DestinationExchangeKey != nil {
		in, out := &in.DestinationExchangeKey, &out.DestinationExchangeKey
		*out = new(string)
		**out = **in
	}
	if in.DestinationProperties != nil {
		in, out := &in.DestinationProperties, &out.DestinationProperties
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationProtocol != nil {
		in, out := &in.DestinationProtocol, &out.DestinationProtocol
		*out = new(string)
		**out = **in
	}
	if in.DestinationPublishProperties != nil {
		in, out := &in.DestinationPublishProperties, &out.DestinationPublishProperties
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationQueue != nil {
		in, out := &in.DestinationQueue, &out.DestinationQueue
		*out = new(string)
		**out = **in
	}
	if in.DestinationQueueArguments != nil {
		in, out := &in.DestinationQueueArguments, &out.DestinationQueueArguments
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DestinationURI != nil {
		in, out := &in.DestinationURI, &out.DestinationURI
		*out = new(string)
		**out = **in
	}
	if in.PrefetchCount != nil {
		in, out := &in.PrefetchCount, &out.PrefetchCount
		*out = new(float64)
		**out = **in
	}
	if in.ReconnectDelay != nil {
		in, out := &in.ReconnectDelay, &out.ReconnectDelay
		*out = new(float64)
		**out = **in
	}
	if in.SourceAddress != nil {
		in, out := &in.SourceAddress, &out.SourceAddress
		*out = new(string)
		**out = **in
	}
	if in.SourceDeleteAfter != nil {
		in, out := &in.SourceDeleteAfter, &out.SourceDeleteAfter
		*out = new(string)
		**out = **in
	}
	if in.SourceExchange != nil {
		in, out := &in.SourceExchange, &out.SourceExchange
		*out = new(string)
		**out = **in
	}
	if in.SourceExchangeKey != nil {
		in, out := &in.SourceExchangeKey, &out.SourceExchangeKey
		*out = new(string)
		**out = **in
	}
	if in.SourcePrefetchCount != nil {
		in, out := &in.SourcePrefetchCount, &out.SourcePrefetchCount
		*out = new(float64)
		**out = **in
	}
	if in.SourceProtocol != nil {
		in, out := &in.SourceProtocol, &out.SourceProtocol
		*out = new(string)
		**out = **in
	}
	if in.SourceQueue != nil {
		in, out := &in.SourceQueue, &out.SourceQueue
		*out = new(string)
		**out = **in
	}
	if in.SourceURI != nil {
		in, out := &in.SourceURI, &out.SourceURI
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InfoParameters.
func (in *InfoParameters) DeepCopy() *InfoParameters {
	if in == nil {
		return nil
	}
	out := new(InfoParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Shovel) DeepCopyInto(out *Shovel) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Shovel.
func (in *Shovel) DeepCopy() *Shovel {
	if in == nil {
		return nil
	}
	out := new(Shovel)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Shovel) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ShovelInitParameters) DeepCopyInto(out *ShovelInitParameters) {
	*out = *in
	if in.Info != nil {
		in, out := &in.Info, &out.Info
		*out = make([]InfoInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ShovelInitParameters.
func (in *ShovelInitParameters) DeepCopy() *ShovelInitParameters {
	if in == nil {
		return nil
	}
	out := new(ShovelInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ShovelList) DeepCopyInto(out *ShovelList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Shovel, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ShovelList.
func (in *ShovelList) DeepCopy() *ShovelList {
	if in == nil {
		return nil
	}
	out := new(ShovelList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ShovelList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ShovelObservation) DeepCopyInto(out *ShovelObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Info != nil {
		in, out := &in.Info, &out.Info
		*out = make([]InfoObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Vhost != nil {
		in, out := &in.Vhost, &out.Vhost
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ShovelObservation.
func (in *ShovelObservation) DeepCopy() *ShovelObservation {
	if in == nil {
		return nil
	}
	out := new(ShovelObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ShovelParameters) DeepCopyInto(out *ShovelParameters) {
	*out = *in
	if in.Info != nil {
		in, out := &in.Info, &out.Info
		*out = make([]InfoParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Vhost != nil {
		in, out := &in.Vhost, &out.Vhost
		*out = new(string)
		**out = **in
	}
	if in.VhostRef != nil {
		in, out := &in.VhostRef, &out.VhostRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.VhostSelector != nil {
		in, out := &in.VhostSelector, &out.VhostSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ShovelParameters.
func (in *ShovelParameters) DeepCopy() *ShovelParameters {
	if in == nil {
		return nil
	}
	out := new(ShovelParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ShovelSpec) DeepCopyInto(out *ShovelSpec) {
	*out = *in
	in.ManagedResourceSpec.DeepCopyInto(&out.ManagedResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ShovelSpec.
func (in *ShovelSpec) DeepCopy() *ShovelSpec {
	if in == nil {
		return nil
	}
	out := new(ShovelSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ShovelStatus) DeepCopyInto(out *ShovelStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ShovelStatus.
func (in *ShovelStatus) DeepCopy() *ShovelStatus {
	if in == nil {
		return nil
	}
	out := new(ShovelStatus)
	in.DeepCopyInto(out)
	return out
}
